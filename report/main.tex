\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{natbib}
\usepackage{hyperref}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{listings}
\usepackage{color}
\usepackage{courier}
\usepackage{geometry}

\geometry{margin=2.5cm}

\definecolor{codegray}{rgb}{0.95,0.95,0.95}

\lstdefinelanguage{Lua}{
  morekeywords={and, break, do, else, elseif, end, false, for, function, goto, if, in, local, nil, not, or, repeat, return, then, true, until, while},
  sensitive=true,
  morecomment=[l]{--},
  morestring=[b]",
}

\lstset{
  backgroundcolor=\color{codegray},
  basicstyle=\footnotesize\ttfamily,
  breaklines=true,
  frame=single,
  language=Lua,
  showstringspaces=false,
  columns=fullflexible
}

\title{Lua \\ [0.2em]\large Eine minimalistische Skriptsprache für Einbettung und Erweiterung}
\author{Andreas Affentranger \& Rafael Uttinger}
\date{\today}
\begin{document}

\maketitle

\section*{Geschichte}

Lua (\textit{Mond} auf portugiesisch) ist eine dynamisch typisierte Skriptsprache, welche 1993 an der Pontifical Catholic University of Rio de Janeiro veröffentlicht und seither kontinuierlich weiterentwickelt wurde. Aktuell rangiert Lua auf Platz 33 des TIOBE Index. Bekannt wurde die Sprache für ihre Erweiterbarkeit und Portabilität.

\section*{Konzepte \& Paradigmen}

Lua Source Code wird mittels dem \texttt{luac} Compiler in Bytecode kompiliert und durch den \texttt{lua} Interpreter interpretiert. Für Applikationen mit erhöhtem Perfomance Bedarf existiert ein unabhängiger LuaJIT Compiler.

Lua ist eine Multiparadigmen Sprache, welche sowohl Konzepte aus der prozeduralen, der imperativen, objektorientierten als auch funktionalen Welt vereinigt.

\subsection*{Leichtgewichtigkeit, Embedding \& Anwendungsbereich}

Lua wurde mit dem Ziel entworfen, eine schlanke und leicht einbettbare Sprache zu sein. Dies zeigt sich unter anderem daran, dass Lua 5.4 lediglich 20 reservierte Keywords umfasst:

\begin{lstlisting}
and	break	do	else	elseif	end
false	for	goto 	if	in	local
nil	not	repeat	or	return	then
true	until	while	function
\end{lstlisting}

Die Philosophie der Sprache besagt dabei, dass nur elementare Bausteine als Keywords angeboten werden sollen. Komplexere Konstrukte können aus diesen Bausteinen kombinatorisch erzeugt werden. Die Leichtgewichtigkeit zeigt sich auch im Source Code von Lua. Insgesamt besteht dieser aus rund 31’000 Linien C. Der gesamte Lua 5.4.7 tarball wiegt unkomprimiert 1.3 MB.
Lua ist eine embedded Sprache sie verfügt über eine gut dokumentierte C API, integriert aber auch mit C++, Java C\# und vielen weiteren Sprachen. All dies macht Lua zur perfekten Sprache für die Einbettung und Erweiterung von bestehender Software.
Einige bekannte Applikationen, welche Lua für ihr Plugin-Management integrieren sind:

\begin{itemize}
  \item \textbf{Adobe Lightroom} – zur Automatisierung und Erweiterung durch Plugins
  \item \textbf{World of Warcraft} – Add-ons und Interface-Modifikationen
  \item \textbf{Neovim} – als Skriptsprache für Konfiguration und Plugins
\end{itemize}

\section*{Luarocks – Package Manager}

\texttt{luarocks} ist der Paketmanger von Lua. Analog zu Paketmanager wie \texttt{pip} oder \texttt{npm} erlaubt er die Installation von Lua Modulen (auch rocks genannt) dritter. Ein zentraler Index für rocks findet sich unter: \url{https://luarocks.org/}

\section*{Datenstrukturen}

Lua kennt nur eine komplexe Datenstruktur, die Tabelle. Ein Tabelle kann in ihrem Verhalten verschiede weitere Datenstrukturen wie zum Beispiel eine Liste, eine Map, ein Set, aber auch Objekte verkörpern. Anbei eine Lua Tabelle als Liste

\begin{lstlisting}
local array = {"apple","banana", 4}
print("Oh-yeah 1-based indexes!:" , array[1])
print(array[3])
\end{lstlisting}

Oder als Set

\begin{lstlisting}
-- Create a set
local set = { "apple", "banana", "orange" }

-- Convert to set semantics
local function to_set(t)
  local s = {}
  for _, v in ipairs(t) do
    s[v] = true
  end
  return s
end

local fruits = to_set(set)

-- Membership test
print(fruits["banana"])  -- true
print(fruits["grape"])   -- nil (false)

-- Add element
fruits["grape"] = true

-- Remove element
fruits["apple"] = nil
\end{lstlisting}

\section*{Objekorientierte Komponenten}

Lua unterstützt Objektorientierte Konzepte. Wie wir es auch von Objekten in Sprachen wie Java kennen, haben Tabellen in Lua ein State und können mit \texttt{self} Bezug auf sich selber nehmen.

\begin{verbatim}
TODO: Example
\end{verbatim}

\section*{Funktionale Komponenten}

In Lua sind Funktionen first-class values, dass heisst sie können in Variablen gespeichert, als Argumente mitgegeben oder als Rückgabewert zurückgegeben werden. Dies erlaubt die Konstruktion von Funktionen höherer Ordnung.

\begin{lstlisting}
local f = function (x, y) return x + y end
print(f(2, 3))
-- prints 5
\end{lstlisting}

Ebenso unterstützt Lua die Verwendung von Lambdas:

\begin{lstlisting}
print((function(x, y) return x * y end)(3, 4))
-- prints 12
\end{lstlisting}

Closures erlauben das “einfangen” von Werten aus der Umgebung:

\begin{lstlisting}
function make_adder(x)
	return  function(y)
		return x + y
	end
end

add5 = make_adder(5)
print(add5(10))
-- prints 15
\end{lstlisting}

\section*{Rekursion \& Tailrekursion}

Rekursion wird in Lua nativ unterstützt. Die Sprache erkennt Tailrekursion automatisch und optimiert den Call-Stack entsprechend. Ein Beispiel:

\begin{lstlisting}
function fact(n, acc)
  acc = acc or 1
  if n == 0 then
    return acc
  else
    return fact(n - 1, n * acc)
  end
end

print(fact(5)) -- Ausgabe: 120
\end{lstlisting}

Rekursive Mechanismen können auch in Metatabellen genutzt werden. Dies erlaubt z.B. vererbte Property-Lookups über verschachtelte \texttt{\_\_index}-Metamethoden:

\begin{lstlisting}
function create_nested_lookup(level)
  if level == 0 then
    return { value = "default" }
  end

  local parent = create_nested_lookup(level - 1)
  local child = {}
  setmetatable(child, { __index = parent })
  return child
end

local obj = create_nested_lookup(3)
print(obj.value)  -- Ausgabe: default
\end{lstlisting}

\section*{Nebenläufigkeit}

Lua Code wird auf einem einzelnen Thread ausgeführt. Parallele Ausführung auf mehreren Threads wird nicht unterstützt. Allerdings kennt Lua das Konzept von Coroutinen. Coroutinen sind Funktionen, welche in einem speziellen Kontext ausgeführt werden. Sie sind non-preemtive, können also nicht von aussen durch den Scheduler unterbrochen werden. Coroutinen können jedoch an geeigneten Stellen ihren aktuellen Status speichern \& die Ausführung unterbrechen, um einer anderen Coroutine die Möglichkeit zu geben ihre Berechnungen weiterzuführen. Durch dieses Wechselspiel zwischen Coroutinen entsteht der Anschein echter Parallelität.

\begin{lstlisting}
function count_to_n(n)
  for i = 1, n do
    print("Counting: " .. i)
    coroutine.yield()  -- pause execution here
  end
end

-- Create a coroutine
co = coroutine.create(function() count_to_n(3) end)

-- Resume the coroutine in steps
while coroutine.status(co) ~= "dead" do
  print("Resuming coroutine...")
  coroutine.resume(co)
end

print("Coroutine has finished.")
-- ouput
-- Resuming coroutine...
-- Counting: 1
-- Resuming coroutine...
-- Counting: 2
-- Resuming coroutine...
-- Counting: 3
-- Coroutine has finished.
\end{lstlisting}

\end{document}